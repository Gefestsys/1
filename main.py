import asyncio
import threading
import time
import queue
from collections import defaultdict
from typing import Dict, Set, Optional
import signal
import sys

from pybit.unified_trading import HTTP, WebSocket
from aiogram import Bot
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

from db_sqlite import UserManager
from localization import get_text
from Exchange import ExchangeLinks
from config import TELEGRAM_TOKEN, TESTNET, logger


class PriceMonitor:
    """–ö–ª–∞—Å—Å –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ü–µ–Ω –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç"""

    def __init__(self):
        self.bot = Bot(token=TELEGRAM_TOKEN)
        self.symbols: list = []
        self.user_prices: Dict[int, Dict[str, tuple]] = defaultdict(dict)
        self.user_settings: Dict[int, dict] = {}
        self.active_users: Set[int] = set()
        self.notification_queue = queue.Queue()
        self.is_running = True
        self.price_data_received = False  # –§–ª–∞–≥ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö

        # WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ (–æ–¥–Ω–æ –¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π)
        self.ws: Optional[WebSocket] = None
        self.ws_lock = threading.Lock()

        # –ü–æ—Ç–æ–∫–∏
        self.threads = []

        # Event loop –¥–ª—è aiogram
        self.bot_loop = None

    @staticmethod
    def format_price(price: float) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ü–µ–Ω—ã —Å —É–¥–∞–ª–µ–Ω–∏–µ–º –ª–∏—à–Ω–∏—Ö –Ω—É–ª–µ–π"""
        if price == 0:
            return "0"

        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–Ω–∞—á–∞—â–∏—Ö —Ü–∏—Ñ—Ä
        if price >= 1000:
            # –î–ª—è –±–æ–ª—å—à–∏—Ö —á–∏—Å–µ–ª –ø–æ–∫–∞–∑—ã–≤–∞–µ–º 2 –∑–Ω–∞–∫–∞ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π
            formatted = f"{price:.2f}"
        elif price >= 1:
            # –î–ª—è —á–∏—Å–µ–ª –æ—Ç 1 –¥–æ 1000 –ø–æ–∫–∞–∑—ã–≤–∞–µ–º 4 –∑–Ω–∞–∫–∞ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π
            formatted = f"{price:.4f}"
        elif price >= 0.01:
            # –î–ª—è —á–∏—Å–µ–ª –æ—Ç 0.01 –¥–æ 1 –ø–æ–∫–∞–∑—ã–≤–∞–µ–º 6 –∑–Ω–∞–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π
            formatted = f"{price:.6f}"
        else:
            # –î–ª—è –æ—á–µ–Ω—å –º–∞–ª—ã—Ö —á–∏—Å–µ–ª –ø–æ–∫–∞–∑—ã–≤–∞–µ–º 8 –∑–Ω–∞–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π
            formatted = f"{price:.8f}"

        # –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –Ω—É–ª–∏ —Å–ø—Ä–∞–≤–∞
        if '.' in formatted:
            formatted = formatted.rstrip('0').rstrip('.')

        return formatted

    @staticmethod
    def get_all_symbols() -> list:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö —Ñ—å—é—á–µ—Ä—Å–Ω—ã—Ö –ø–∞—Ä"""
        try:
            http = HTTP(testnet=TESTNET)
            response = http.get_instruments_info(category="linear", limit=1000)

            if response.get("result") and response["result"].get("list"):
                symbols = []
                for item in response["result"]["list"]:
                    if item.get("symbol") and item.get("status") == "Trading":
                        symbols.append(item["symbol"])

                # –£–±–∏—Ä–∞–µ–º –ª–∏–º–∏—Ç - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –≤—Å–µ —Å–∏–º–≤–æ–ª—ã
                return symbols if symbols else []
            else:
                logger.error("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä –∏–ª–∏ –ø—É—Å—Ç–æ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç")
                return []
        except Exception as e:
            logger.error(f"Error fetching symbols: {e}")
            return []

    @staticmethod
    def create_exchange_keyboard(symbol: str, user_exchange: str, language: str) -> InlineKeyboardMarkup:
        """–°–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –¥–ª—è —Ç–æ—Ä–≥–æ–≤–æ–π –ø–∞—Ä—ã"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –æ—Ç ExchangeLinks
            keyboard_data = ExchangeLinks.create_exchange_keyboard(symbol, user_exchange, language)

            # –°–æ–∑–¥–∞–µ–º aiogram –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
            buttons = []
            for row in keyboard_data['inline_keyboard']:
                button_row = []
                for button in row:
                    button_row.append(InlineKeyboardButton(
                        text=button['text'],
                        url=button['url']
                    ))
                buttons.append(button_row)

            return InlineKeyboardMarkup(inline_keyboard=buttons)

        except Exception as e:
            logger.error(f"Error creating exchange keyboard: {e}")
            # –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ —Å–æ–∑–¥–∞–µ–º –ø—Ä–æ—Å—Ç—É—é –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å TradingView
            tradingview_link = ExchangeLinks.get_tradingview_link(symbol)
            button_text = ExchangeLinks.format_exchange_button(symbol, 'tradingview', language)

            return InlineKeyboardMarkup(inline_keyboard=[[
                InlineKeyboardButton(text=button_text, url=tradingview_link)
            ]])

    @staticmethod
    def get_exchange_display_name(exchange: str, language: str) -> str:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º–æ–≥–æ –∏–º–µ–Ω–∏ –±–∏—Ä–∂–∏"""
        exchange_names = {
            'binance': 'Binance',
            'bybit': 'Bybit',
            'bingx': 'BingX',
            'okx': 'OKX',
            'bitget': 'Bitget',
            'tradingview': 'TradingView'
        }
        return exchange_names.get(exchange.lower(), exchange.upper())

    async def send_notification_async(self, user_id: int, symbol: str, old_price: float,
                                      new_price: float, percentage_change: float):
        """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ Telegram —Å —É—á–µ—Ç–æ–º —è–∑—ã–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º —è–∑—ã–∫ –∏ –±–∏—Ä–∂—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            user_language = UserManager.get_user_language(user_id)
            user_exchange = UserManager.get_user_exchange(user_id)

            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —ç–º–æ–¥–∑–∏ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ü–µ–Ω—ã
            change_emoji = "üìà" if percentage_change > 0 else "üìâ"

            # –ü–æ–ª—É—á–∞–µ–º –ª–æ–∫–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ —Ç–µ–∫—Å—Ç—ã
            fixed_price_text = get_text('notification_fixed_price', user_language)
            current_price_text = get_text('notification_current_price', user_language)
            change_text = get_text('notification_change', user_language)
            time_text = get_text('notification_time', user_language)

            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Ü–µ–Ω—ã —Å —É–¥–∞–ª–µ–Ω–∏–µ–º –ª–∏—à–Ω–∏—Ö –Ω—É–ª–µ–π
            old_price_formatted = self.format_price(old_price)
            new_price_formatted = self.format_price(new_price)

            # –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Å–Ω–æ–≤–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            message = (
                f"üí∞ *{symbol}* {change_emoji}\n\n"
                f"{fixed_price_text}: `{old_price_formatted}`\n"
                f"{current_price_text}: `{new_price_formatted}`\n"
                f"{change_text}: *{percentage_change:+.2f}%*\n"
                f"{time_text}: {time.strftime('%H:%M:%S')}"
            )

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Å–∏–º–≤–æ–ª–∞ –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –±–∏—Ä–∂–µ
            if (user_exchange.lower() != 'tradingview' and
                    not ExchangeLinks.check_symbol_availability(symbol, user_exchange)):

                # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏
                exchange_display_name = self.get_exchange_display_name(user_exchange, user_language)

                if user_language == 'en':
                    unavailable_text = f"\n\n‚ö†Ô∏è *Not available on {exchange_display_name}*"
                else:
                    unavailable_text = f"\n\n‚ö†Ô∏è *–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ –Ω–∞ {exchange_display_name}*"

                message += unavailable_text

            # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–ª—è —Ç–æ—Ä–≥–æ–≤–æ–π –ø–∞—Ä—ã
            keyboard = self.create_exchange_keyboard(symbol, user_exchange, user_language)

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π
            await self.bot.send_message(
                user_id,
                message,
                parse_mode='Markdown',
                reply_markup=keyboard
            )

            logger.info(
                f"Alert sent to user {user_id} ({user_language}, {user_exchange}): {symbol} {percentage_change:+.2f}%")

        except Exception as e:
            logger.error(f"Failed to send notification to user {user_id}: {e}")

    def send_notification_sync(self, user_id: int, symbol: str, old_price: float,
                               new_price: float, percentage_change: float):
        """–°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –æ–±–µ—Ä—Ç–∫–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è"""
        try:
            # –°–æ–∑–¥–∞–µ–º –∫–æ—Ä—É—Ç–∏–Ω—É
            coroutine = self.send_notification_async(user_id, symbol, old_price, new_price, percentage_change)

            # –ï—Å–ª–∏ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–π event loop, –ø–ª–∞–Ω–∏—Ä—É–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ
            if self.bot_loop and self.bot_loop.is_running():
                asyncio.run_coroutine_threadsafe(coroutine, self.bot_loop)
            else:
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π event loop –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ—Ç–æ–∫–∞
                new_loop = asyncio.new_event_loop()
                asyncio.set_event_loop(new_loop)
                try:
                    new_loop.run_until_complete(coroutine)
                finally:
                    new_loop.close()

        except Exception as e:
            logger.error(f"Error in send_notification_sync: {e}")

    def notification_worker(self):
        """–í–æ—Ä–∫–µ—Ä –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π"""
        logger.info("Notification worker started")

        while self.is_running:
            try:
                # –ü–æ–ª—É—á–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∏–∑ –æ—á–µ—Ä–µ–¥–∏ —Å —Ç–∞–π–º–∞—É—Ç–æ–º
                notification = self.notification_queue.get(timeout=0.1)
                self.send_notification_sync(**notification)
                self.notification_queue.task_done()

                # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ —á—Ç–æ–±—ã –Ω–µ —Å–ø–∞–º–∏—Ç—å
                time.sleep(0.1)

            except queue.Empty:
                continue
            except Exception as e:
                logger.error(f"Error in notification worker: {e}")

    async def bot_worker(self):
        """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –≤–æ—Ä–∫–µ—Ä –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π"""
        logger.info("Bot worker started")

        while self.is_running:
            try:
                await asyncio.sleep(0.1)

                # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∏–∑ –æ—á–µ—Ä–µ–¥–∏
                notifications_to_process = []

                # –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
                while not self.notification_queue.empty():
                    try:
                        notification = self.notification_queue.get_nowait()
                        notifications_to_process.append(notification)
                        self.notification_queue.task_done()
                    except queue.Empty:
                        break

                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
                if notifications_to_process:
                    tasks = []
                    for notification in notifications_to_process:
                        task = self.send_notification_async(**notification)
                        tasks.append(task)

                    # –ñ–¥–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤—Å–µ—Ö –∑–∞–¥–∞—á
                    if tasks:
                        await asyncio.gather(*tasks, return_exceptions=True)

            except Exception as e:
                logger.error(f"Error in bot worker: {e}")
                await asyncio.sleep(1)

    def start_bot_worker(self):
        """–ó–∞–ø—É—Å–∫ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –≤–æ—Ä–∫–µ—Ä–∞ –±–æ—Ç–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ"""

        def run_bot_worker():
            worker_loop = None
            try:
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π event loop –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ—Ç–æ–∫–∞
                worker_loop = asyncio.new_event_loop()
                asyncio.set_event_loop(worker_loop)
                self.bot_loop = worker_loop

                # –ó–∞–ø—É—Å–∫–∞–µ–º bot worker
                worker_loop.run_until_complete(self.bot_worker())

            except Exception as e:
                logger.error(f"Bot worker thread error: {e}")
            finally:
                try:
                    if worker_loop is not None:
                        worker_loop.close()
                except Exception:
                    pass
                self.bot_loop = None

        bot_thread = threading.Thread(target=run_bot_worker, name="bot_worker", daemon=True)
        bot_thread.start()
        return bot_thread

    def update_user_settings(self):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
        try:
            subscribed_users = UserManager.get_all_subscribed_users()
            current_active = set()

            logger.debug(f"Found {len(subscribed_users)} subscribed users")

            for user_data in subscribed_users:
                user_id = user_data['user_id']
                current_active.add(user_id)

                # –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –µ—Å–ª–∏ –æ–Ω–∏ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å
                if (user_id not in self.user_settings or
                        self.user_settings[user_id]['period'] != user_data['period'] or
                        self.user_settings[user_id]['percent'] != user_data['percent'] or
                        self.user_settings[user_id]['language'] != user_data['language'] or
                        self.user_settings[user_id]['exchange'] != user_data['exchange']):

                    self.user_settings[user_id] = {
                        'period': user_data['period'],
                        'percent': user_data['percent'],
                        'language': user_data['language'],
                        'exchange': user_data['exchange']
                    }

                    # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ü–µ–Ω—ã –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫
                    if user_id in self.user_prices:
                        current_time = time.time()
                        for symbol in self.user_prices[user_id]:
                            _, price = self.user_prices[user_id][symbol]
                            self.user_prices[user_id][symbol] = (current_time, price)

                    logger.info(f"Updated settings for user {user_id}: "
                                f"period={user_data['period']}, percent={user_data['percent']}, "
                                f"language={user_data['language']}, exchange={user_data['exchange']}")

            # –£–¥–∞–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            inactive_users = self.active_users - current_active
            for user_id in inactive_users:
                if user_id in self.user_prices:
                    del self.user_prices[user_id]
                if user_id in self.user_settings:
                    del self.user_settings[user_id]
                logger.info(f"Removed data for inactive user {user_id}")

            self.active_users = current_active

        except Exception as e:
            logger.error(f"Error updating user settings: {e}")

    def process_price_update(self, symbol: str, price: float):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ü–µ–Ω—ã –ø–æ —Å–∏–º–≤–æ–ª—É"""
        current_time = time.time()

        if not self.active_users:
            logger.debug("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ü–µ–Ω—ã.")
            return

        for user_id in self.active_users:
            try:
                user_settings = self.user_settings.get(user_id)
                if not user_settings:
                    logger.debug(f"–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} –Ω–µ –Ω–∞–π–¥–µ–Ω—ã, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º.")
                    continue

                period_seconds = user_settings['period'] * 60
                percent_threshold = user_settings['percent']

                # –ï—Å–ª–∏ —Å–∏–º–≤–æ–ª –µ—â—ë –Ω–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç—Å—è ‚Äî –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º
                if symbol not in self.user_prices[user_id]:
                    self.user_prices[user_id][symbol] = (current_time, price)
                    logger.info(
                        f"[User {user_id}] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ü–µ–Ω—ã –¥–ª—è {symbol}: {self.format_price(price)} –≤ {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(current_time))}")
                    continue

                fixed_time, fixed_price = self.user_prices[user_id][symbol]
                elapsed = current_time - fixed_time

                # –í—ã—á–∏—Å–ª—è–µ–º –ø—Ä–æ—Ü–µ–Ω—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è
                if fixed_price > 0:
                    percentage_change = ((price - fixed_price) / fixed_price) * 100
                else:
                    percentage_change = 0

                logger.debug(
                    f"[User {user_id}] –û–±—Ä–∞–±–æ—Ç–∫–∞ {symbol}: —Å—Ç–∞—Ä–∞—è —Ü–µ–Ω–∞ {self.format_price(fixed_price)}, –Ω–æ–≤–∞—è —Ü–µ–Ω–∞ {self.format_price(price)}, –∏–∑–º–µ–Ω–µ–Ω–∏–µ {percentage_change:.2f}%, –ø—Ä–æ—à–ª–æ {elapsed:.1f} —Å–µ–∫")

                if abs(percentage_change) >= percent_threshold:
                    # –ü–æ—Ä–æ–≥ –¥–æ—Å—Ç–∏–≥–Ω—É—Ç ‚Äî –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∏ —Ñ–∏–∫—Å–∏—Ä—É–µ–º –Ω–æ–≤—É—é —Ü–µ–Ω—É
                    self.notification_queue.put_nowait({
                        'user_id': user_id,
                        'symbol': symbol,
                        'old_price': fixed_price,
                        'new_price': price,
                        'percentage_change': percentage_change
                    })
                    self.user_prices[user_id][symbol] = (current_time, price)
                    logger.info(
                        f"[User {user_id}] –ü–æ—Ä–æ–≥ {percent_threshold}% –¥–æ—Å—Ç–∏–≥–Ω—É—Ç –ø–æ {symbol}. –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ. –¶–µ–Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞ –¥–æ {self.format_price(price)}")

                elif elapsed >= period_seconds:
                    # –í—Ä–µ–º—è –≤—ã—à–ª–æ –±–µ–∑ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –ø–æ—Ä–æ–≥–∞ ‚Äî –ø—Ä–æ—Å—Ç–æ —Ñ–∏–∫—Å–∏—Ä—É–µ–º –Ω–æ–≤—É—é —Ü–µ–Ω—É
                    self.user_prices[user_id][symbol] = (current_time, price)
                    logger.info(
                        f"[User {user_id}] –ü–µ—Ä–∏–æ–¥ {period_seconds} —Å–µ–∫ –∏—Å—Ç–µ–∫ –¥–ª—è {symbol}. –¶–µ–Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞ –¥–æ {self.format_price(price)} –±–µ–∑ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.")

            except Exception as e:
                logger.error(f"Error processing price update for user {user_id}: {e}")

    def websocket_message_handler(self, message):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–æ–±—â–µ–Ω–∏–π WebSocket"""
        try:
            if not isinstance(message, dict):
                logger.debug(f"Received non-dict message: {type(message)}")
                return

            if "data" not in message:
                logger.debug(f"Message without 'data' field: {message}")
                return

            data_list = message["data"] if isinstance(message["data"], list) else [message["data"]]

            processed_count = 0
            for data in data_list:
                if not isinstance(data, dict):
                    continue

                symbol = data.get("symbol")
                last_price = data.get("lastPrice")

                if symbol and last_price:
                    try:
                        price = float(last_price)
                        self.process_price_update(symbol, price)
                        processed_count += 1

                        # –û—Ç–º–µ—á–∞–µ–º —á—Ç–æ –ø–æ–ª—É—á–∏–ª–∏ –¥–∞–Ω–Ω—ã–µ
                        if not self.price_data_received:
                            self.price_data_received = True
                            logger.info(f"First price data received: {symbol} = {self.format_price(price)}")

                    except (ValueError, TypeError) as e:
                        logger.warning(f"Invalid price data for {symbol}: {last_price} - {e}")

            if processed_count > 0:
                logger.debug(f"Processed {processed_count} price updates")

        except Exception as e:
            logger.error(f"Error in WebSocket message handler: {e}")

    def start_websocket(self):
        """–ó–∞–ø—É—Å–∫ WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
        max_retries = 100
        retry_delay = 5

        for attempt in range(max_retries):
            try:
                logger.info(f"Starting WebSocket connection (attempt {attempt + 1}/{max_retries})")

                with self.ws_lock:
                    self.ws = WebSocket(
                        testnet=TESTNET,
                        channel_type="linear",
                        retries=100
                    )

                # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ —Ç–∏–∫–µ—Ä—ã —Å–∏–º–≤–æ–ª–æ–≤ –ø–æ —á–∞—Å—Ç—è–º (WebSocket –º–æ–∂–µ—Ç –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å –±–æ–ª—å—à–∏–µ —Å–ø–∏—Å–∫–∏)
                chunk_size = 50
                for i in range(0, len(self.symbols), chunk_size):
                    chunk = self.symbols[i:i + chunk_size]
                    logger.info(f"Subscribing to symbols {i + 1}-{min(i + chunk_size, len(self.symbols))}: {chunk}")

                    try:
                        self.ws.ticker_stream(
                            symbol=chunk,
                            callback=self.websocket_message_handler
                        )
                        time.sleep(0.5)  # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –ø–æ–¥–ø–∏—Å–∫–∞–º–∏
                    except Exception as e:
                        logger.error(f"Failed to subscribe to chunk {chunk}: {e}")

                logger.info("WebSocket connection established successfully")

                # –ú–æ–Ω–∏—Ç–æ—Ä–∏–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
                last_data_time = time.time()
                while self.is_running:
                    current_time = time.time()

                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
                    if self.price_data_received:
                        last_data_time = current_time
                    elif current_time - last_data_time > 120:  # 2 –º–∏–Ω—É—Ç—ã –±–µ–∑ –¥–∞–Ω–Ω—ã—Ö
                        logger.warning("No price data received for 2 minutes, connection may be dead")
                        raise Exception("WebSocket connection seems dead")

                    time.sleep(1)

                break

            except Exception as e:
                logger.error(f"WebSocket error (attempt {attempt + 1}): {e}")

                with self.ws_lock:
                    if self.ws:
                        try:
                            self.ws.exit()
                        except Exception:
                            pass
                        self.ws = None

                if attempt < max_retries - 1:
                    logger.info(f"Retrying WebSocket connection in {retry_delay} seconds...")
                    time.sleep(retry_delay)
                    retry_delay = min(retry_delay * 2, 30)  # –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
                else:
                    logger.critical("Failed to establish WebSocket connection after all retries")
                    raise

    def settings_updater(self):
        """–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
        logger.info("Settings updater started")

        while self.is_running:
            try:
                self.update_user_settings()

                # –û—á–∏—Å—Ç–∫–∞ –∏—Å—Ç–µ–∫—à–∏—Ö –ø–æ–¥–ø–∏—Å–æ–∫
                UserManager.cleanup_expired_subscriptions()

                # –í—ã–≤–æ–¥–∏–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
                current_time = int(time.time())
                if current_time % 300 == 0:
                    logger.info(f"Active users: {len(self.active_users)}, "
                                f"Tracked symbols: {len(self.symbols)}, "
                                f"Queue size: {self.notification_queue.qsize()}")

                # –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
                for _ in range(30):
                    if not self.is_running:
                        break
                    time.sleep(1)

            except Exception as e:
                logger.error(f"Error in settings updater: {e}")
                time.sleep(5)

    def start(self):
        """–ó–∞–ø—É—Å–∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
        logger.info("Starting price monitor...")

        # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Å–∏–º–≤–æ–ª–æ–≤
        self.symbols = self.get_all_symbols()
        if not self.symbols:
            logger.critical("No symbols found, cannot start monitoring")
            return

        logger.info(
            f"Will monitor {len(self.symbols)} symbols: {', '.join(self.symbols[:10])}{'...' if len(self.symbols) > 10 else ''}")

        # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ—Ç–æ–∫–∏
        threads_to_start = [
            ("bot_worker", self.start_bot_worker),
            ("settings_updater", self.settings_updater),
            ("websocket", self.start_websocket)
        ]

        for name, target in threads_to_start:
            if name == "bot_worker":
                # –î–ª—è bot_worker –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥
                thread = target()
            else:
                thread = threading.Thread(target=target, name=name, daemon=True)
                thread.start()

            self.threads.append(thread)
            logger.info(f"Started {name} thread")

        logger.info("Price monitor started successfully")

        # –ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª
        try:
            while self.is_running:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ—Ç–æ–∫–æ–≤
                for thread in self.threads:
                    if hasattr(thread, 'is_alive') and not thread.is_alive():
                        logger.error(f"Thread {getattr(thread, 'name', 'unknown')} died unexpectedly")

                time.sleep(10)

        except KeyboardInterrupt:
            logger.info("Received interrupt signal")
        finally:
            self.stop()

    async def cleanup_bot(self):
        """–û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤ –±–æ—Ç–∞"""
        try:
            await self.bot.session.close()
            logger.info("Bot session closed")
        except Exception as e:
            logger.error(f"Error closing bot session: {e}")

    def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
        logger.info("Stopping price monitor...")

        self.is_running = False

        # –ó–∞–∫—Ä—ã–≤–∞–µ–º WebSocket
        with self.ws_lock:
            if self.ws:
                try:
                    self.ws.exit()
                except Exception:
                    pass

        # –ó–∞–∫—Ä—ã–≤–∞–µ–º bot session
        if self.bot_loop and self.bot_loop.is_running():
            asyncio.run_coroutine_threadsafe(self.cleanup_bot(), self.bot_loop)

        # –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ—Ç–æ–∫–æ–≤
        for thread in self.threads:
            if hasattr(thread, 'is_alive') and thread.is_alive():
                if hasattr(thread, 'join'):
                    thread.join(timeout=5)

        logger.info("Price monitor stopped")


def signal_handler(signum, _):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è graceful shutdown"""
    logger.info(f"Received signal {signum}, shutting down...")
    sys.exit(0)


def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–∏–≥–Ω–∞–ª–æ–≤
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    try:
        # –°–æ–∑–¥–∞–Ω–∏–µ –∏ –∑–∞–ø—É—Å–∫ –º–æ–Ω–∏—Ç–æ—Ä–∞
        monitor = PriceMonitor()
        monitor.start()

    except Exception as e:
        logger.critical(f"Critical error in main: {e}")
        raise


if __name__ == "__main__":
    main()